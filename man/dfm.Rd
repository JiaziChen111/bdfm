% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dfm.R
\name{dfm}
\alias{dfm}
\title{Estimate a Dynamic Factor Model}
\usage{
dfm(data, factors = 1, lags = "auto", forecasts = 0,
  method = c("bayesian", "ml", "pc"), scale = TRUE, logs = "auto",
  diffs = "auto", outlier_threshold = 4, frequency_mix = "auto",
  pre_differenced = NULL, trans_prior = NULL, trans_shrink = 0,
  trans_df = 0, obs_prior = NULL, obs_shrink = 0, obs_df = NULL,
  identification = "pc_long", keep_posterior = NULL,
  interpolate = FALSE, orthogonal_shocks = FALSE, reps = 1000,
  burn = 500, verbose = interactive(), tol = 0.01)
}
\arguments{
\item{data}{one or multiple time series. The data to be used for estimation.
This can be entered as a \code{"ts"} object of as a matrix. If
\href{https://tsbox.help}{tsbox} is installed, any ts-boxable time series can be
supplied (\code{ts}, \code{xts}, \code{zoo}, \code{data.frame}, \code{data.table}, \code{tbl}, \code{tbl_ts},
\code{tbl_time}, or \code{timeSeries})}

\item{factors}{integer. The number of unobserved factors to be estimated. A
larger number of factors leads to a more complex model.}

\item{lags}{integer. The number of lags in the transition equation. If
\code{"auto"} (default), the number is equal to highest frequency in \code{data}.}

\item{forecasts}{integer. Number of periods ahead to forecasts.}

\item{method}{character. Method to be used; one of \code{"bayesian"}, \code{"ml"} or
`"pc". See details.}

\item{scale}{logical. Should data be scaled before estimation? \code{TRUE}
(default) resolves some numerical problems during estimation. \code{FALSE}
ensures that the coefficient estimates are interpretable.}

\item{logs}{names or index values (see details). Series of which the
logarithm is taken (can be combined with \code{diffs}). If \code{"auto"} (default)
this is done for all series that are differentiated and have no values < 0.}

\item{diffs}{names or index values (see details). Series to be
differentiated. If \code{"auto"} (default), a modified Durbin-Watson test is
performed.}

\item{outlier_threshold}{integer. Observations more than \code{outlier_threshold}
standard deviations from the series mean are removed. This is useful to
increase the stability of the estimation.}

\item{frequency_mix}{integer or \code{"auto"}. Number of high frequency periods
in a low frequency period. If \code{"auto"} (default), this is inferred from the
time series.}

\item{pre_differenced}{names or index values (see details). series entered in
differences (If series are specified in 'diffs', this is not needed.)}

\item{trans_prior}{prior matrix for B in the transition equation. Default is
zeros.}

\item{trans_shrink}{prior tightness on B matrix in transition equation}

\item{trans_df}{prior degree of freedom for transition equation}

\item{obs_prior}{prior matrix for H (loadings) in the observation equation
Default is zeros.}

\item{obs_shrink}{prior tightness on H (loadings) in the observation equation}

\item{obs_df}{named vector (see details). prior degree of freedom
for gamma distribution in the observation equation. This is useful to give specific series a larger weight,
e.g. 1. (default 0, method \code{bayesian} only).}

\item{identification}{names or index values (see details), or character. Factor identification. \code{"pc_long"}
(default) finds series with the most observations over time, on which it uses principal components. '"pc_full"'
uses all observed series, \code{"pc_sub"} finds a submatrix of the data that
maximizes the number of observations for a square (no missing values) data
set. Identification can also be done manually, by supplying names or index
values.}

\item{keep_posterior}{names or index values (see details). Series of which to keep the full posterior distribution of predicted values (method \code{bayesian} only). This is useful for forecasting.}

\item{interpolate}{logical. If data is mixed frequency, should low frequency be interpolated?}

\item{orthogonal_shocks}{return a rotation of the model with orthogonal shocks and factors. This is useful ....}

\item{reps}{number of repetitions for MCMC sampling}

\item{burn}{number of iterations to burn in MCMC sampling}

\item{verbose}{print status of function during evaluation. If ML, print
difference in likelihood at each iteration of the EM algorithm. Default is
\code{TRUE} in interactive mode, \code{FALSE} otherwise, so it does not appear, e.g., in \code{reprex::reprex()}.}

\item{tol}{tolerance for convergence of EM algorithm (method \code{ml} only).}
}
\description{
Estimates a Bayesian or non-Bayesian dynamic factor Model. With the default
options, \code{dfm} calls  automatic procedures that works well in many
circumstances.
}
\details{
\strong{Specifying series}: Individual series can be specified either by \emph{names}
(recommended) or index values. An index value refers to the position of the
series in \code{data}.

\strong{Specifying parameters for specific series}: Parameters for individual
series can be specified using a \emph{named} vector (recommended) or using a
unnamed vector of the same length as as the number of series in \code{data}.
}
\examples{

dta <- cbind(fdeaths, mdeaths)

m0 <- dfm(dta, forecast = 2) # estimation with 2 period forecast
predict(m0)                  # series with imputations and forecasts
summary(m0)                  # summary of the model
factors(m0)                  # estimated factor

# informative priors: giving 'fdeaths' a higher weight
m1 <- dfm(dta, obs_df = c("fdeaths" = 1))
summary(m1)

\dontrun{
# Forecasting U.S. GDP
m1 <- dfm(econ_us,
  pre_differenced = "A191RL1Q225SBEA",
  keep_posterior = "A191RL1Q225SBEA"
)

# interpolating low frequency series
dta_mixed <- econ_us[, c(1, 3)]
predict(dfm(dta_mixed))
predict(dfm(dta_mixed, interpolate = TRUE))
}
}
\seealso{
\code{vignette("dfm")}, for a more comprehensive intro to the package.

\href{http://srlquantitative.com/docs/Factor_Models.pdf}{Practical Implementation of Factor Models} for a comprehensive overview of dynamic factor models.
}
